# Once UI Development Rules

## Core Philosophy
- You are a Design Engineer. We use Once UI for its semantic layout engine and design tokens.
- Priority 1: Semantic clarity. Use high-level atoms to build layouts and set styles (<Column>, <Row>, <Grid>, <Heading>, <Text>).
- Priority 2: Token consistency. Never use hex codes; Use Once UI props whenever possible. If you need additional customization, use inline styles.
- Priotity 3: Always scan for possible components. Once UI provides many generic, flexible and customizable components. The ones you need to create are mostly product-specific ones. Create them in a single folder with a barrel export in an index.ts file. The components should be built from Once UI primitives. You can use inline styles sparingly if the Flex props don't cover a ceretain use case. If excessive style overrides are needed, or the component needs to utilize selectors for states, use a standalone SCSS module. Components should almost always be fluid by default, with width either fitting the content or spanning 100%. Whenever possible, spread the <Row>, <Column> or <Grid> props on the component wrapper so style and size can be overriden from the outside, making them more flexible.
- Priority 4: No "Utility Noise". Avoid Tailwind classes and tools that are not part of the project already.

## Component & Layout Rules
- **Structure**: Never use <div>. Use <Column> for vertical stacking, <Row> for horizontal, and <Grid> for equally sized and distributed elements. The `horizontal` and `vertical` props for the <Row> and <Column> simplify flex layouts. They apply utility classes in the background and keep the main axis consistent, which means that `horizontal` will always set the content to "start", "center", "end", "between" or "around" regardless of direction. Same goes for `vertical`. Use the `center` shorthand to center children on both axis. `position="relative"` is the default for <Row>, <Column> and <Grid>, only add `position` to override it. Use `maxWidth` with "xs" -> "xl" values for page content and layout elements like header, or a number as REM for fixed max-widths. the `maxWidth` and `maxHeight` props automatically add `fillWidth` and `fillHeight` props for fluidity.
- **Spacing**: Use the `gap`, `padding`, `margin` props or shorthands like `paddingX` and `marginTop`. Value can be `SpacingToken` (e.g., "16", "24", "32") or a number that equals to REM. Use `gap="-1"` to collapse stacked borders. Use responsive paddings sparingly, when makes sense. For page paddings, `paddingX="l"` makes sense. For smaller spacings, static ones ("4", "8", "16"...) are usually fine.
- **Sizing**: Use the `fillWidth` and `fillHeight` props instead of `w-full` or `h-full`. Use `fill` as a shorthand for `fillWidth` and `fillHeight`. They automatically add `minWidth="0"` and `minHeight="0"` if not specified.
- **Text**: Use the <Heading> and <Text> component with the `variant` prop (e.g., "display-strong-s", "body-default-m"). A nested <Text> will inherit the parent variant. You can override the weight or size with the `weight` (default or strong) and `size` ("xs" -> "xl") props. Align text with the `align` property on `Text`, `Heading`, `Row` or `Column` (it adds the text-align property, NOT flex alignment!)
- **Colors**: Use the `background` and `onBackground` and `solid` and `onSolid` prop pairs for background + text (e.g., `background="neutral-medium" onBackground="neutral-weak"`) to ensure dark-mode compatibility. The `background` is for general purpose, low-contrast surfaces, and the solid is for high-contrast, usually interactive elements such as backgrounds. The `background` prop has a few additional values: "page", "surface" and "overlay". They behave differently based on theme. Usually the main site background is "page", with large layout elements, such as headers or sidebars being "surface" (but they can also be "page" depending on design aeshetics).
- **Components**: Most components are wrapped in a <Column> or <Row> with Flex props spread on the outer element, making it easy to override component defaults such as paddings, margins or borders.
- **Defaults**: There are several shorthands for styling with the <Row>, <Column> and <Grid>. For example, `border="neutral-alpha-medium"` will apply a 1px solid border if `borderWidth` and `borderStyle` is not specificed. Similarly, `position="sticky"` will apply `top="0"` if not specified otherwise. It's worth checking components, especially the `Flex` and `Grid` to understand which props are necessary and which aren't.
- **Responsive design**: Use the `s`, `m` and `l` breakpoint objects on the <Row>, <Column> and <Grid> components to override layouts and styles at breakpoints. Not all props are supported, but they support inline styles inside the breakpoint object (`<Row s={{style: {...}}}`). Hide and show elements based on breakpoint with the `hide` and `m={{hide: false}}` props. Show or hide elements with the `dark` and `light` props. They are especially important when using the <Logo> components, because the svg doesn't change theme automatically.

## Global Preferences
- Prefer **Functional Components** and **TypeScript**.
- Always ensure components are accessible (ARIA labels, semantic tags). Use `tooltip` for <IconButtons> when the action is not necessary or using several buttons in a group.

## Design & Style
- Once UI has a unique, minimal aeshetics. It can vary based on project and implementation, but it always puts an emphasis on scale, contrast, clarity and proportions.
- Build hierarchy by grouping elements and carefully setting appropriate spacings: the amount of the spacing should be relative to the size of the elements.
- Once UI is a dark-mode first system that stands for extremely high quality. Think of Vercel, Linear and Raycast.
- The general style of Once UI is grounded, simple, performant. Motion is usually provided by atomic components for interactions and states rather than distruptive, layout-shifting, unnecessary animations.

## Recommendations
- The recommended size for <Button> and <IconButton> is `m`, only diverge when the UI is either spacious or very compact.
- Only use responsive spacings (gaps, margins and paddings) when distances need collapse on smaller screens. Most of the time, for general UI elements (cards, groups, etc.), static spacings are enough. Responsive spacings are reserved mostly for large layout elements, like the content area of the page, where 40px looks good on desktop but feels enormous on mobile.
- Adding `align="center"` to a <Row> or <Column> will make ALL nested text elements align to center. It can have uninteded effects when adding them to top-level layout elements. To center the inner element, use the `horizontal="center"` prop, which will add the `justify-content` property correctly, NOT the `text-align` property.